\chapter{Robot Control}
\label{chap:robotcontrol}

\section{Gripper}

\section{UR5 Communication Interface}
In order to control the robot and simultaneously receive data from it, Universal Robots' (UR) Real-Time Data Exchange (RTDE) interface, which is available by default on UR's robots, was used. The RTDE is a low-level communication protocol that operates over a standard TCP/IP connection, enabling external applications to exchange data and control signals with the UR controller at a high frequency \textcolor{red}{ref}. 

The communication protocol itself was implemented using the open-source \texttt{ur\_rtde} C++ library developed by SDU Robotics \textcolor{red}{ref}. The library abstracts the complexities of the binary RTDE protocol, providing a user-friendly object-oriented wrapper, while logically splitting the interface in 3 parts; control, receive and I/O. This allows the user to control movement and data collection separately and at the same time. For this project, the I/O interface was not used as the gripper is controlled on a dedicated separate TCP/IP connection. 

The \texttt{ur\_rtde} library provides C++ movement methods, such as \texttt{moveJ} and \texttt{moveL}, that closely correspond to those found in the UR5 teach pendant. Since the movement path for the throwing sequence was pre-computed, the main control loop utilizes the non-blocking \texttt{speedJ} control command for execution. This command allows the user to continuously input a target joint speed vector, $\mathbf{\dot{q}}_{\text{target}}$, at the control loop frequency (125 Hz for the UR5). The command also requires a specified acceleration limit to reach the target speeds, and a $\Delta t$ (time step) parameter to define the duration of the current control interval. By looping through the pre-computed joint speed sequence, $\mathbf{\dot{q}}$, at the 125 Hz rate, the desired throwing movement is executed.

Movements other than the throwing sequence are also required, these movements use \texttt{moveJ} as to limit the risk of hitting a joint boundary, while not having to map the movement fully beforehand. \texttt{moveJ} allows the user to input a target joint position, a desired speed and acceleration. The move is then executed by interpolating linearly in joint space, which ensures a controlled path and reduces the range of motion needed at each joint. Theoretically, joint boundaries should never be violated using this movement type, provided both the start and end configurations are within the joint limits. This movement type is used for the static ball pickup sequence, for moving the robot to the throwing sequence start position, and for returning to a defined home configuration after the throw.