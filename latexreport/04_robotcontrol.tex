\chapter{Robot Control}
\label{chap:robotcontrol}

\section{Gripper}

The gripper used by the project is WSG50 from Weiss. The connection to the gripper happens with a Transmission Control Protocol (TCP) server and client. The gripper is the TCP server, and the TCP client is made in a c++ class.
To control the gripper 4 functions are used. HOME(), GRIP(), RELEASE(), BYE(). \cite{WSGmanual}

HOME() is called when the connection to the gripper is made. that is to insure the gripper starts in the same position. 

GRIP() function works by the gripper keeps closing until a 80N force is reached.

RELEASE() function works by opening the gripper 5 mm.

BYE() funciton closes the connection to the gripper safely.

Each function returns "ACK function name()" when it starts, and returns "FIN function name()" when it is done. Exept BYE() which only return "FIN BYE()".

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.3]{images/gripper.png} % \includegraphics now works
	\caption{WSG50 Weiss gripper} % \caption now works inside the float
	\label{fig:rwar_image}
\end{figure}


\section{UR5 Communication Interface}
In order to control the robot and simultaneously receive data from it, Universal Robots' (UR) Real-Time Data Exchange (RTDE) interface, which is available by default on UR's robots, was used. The RTDE is a low-level communication protocol that operates over a standard TCP/IP connection, enabling external applications to exchange data and control signals with the UR controller at a high frequency \cite{URrtde}. 

The communication protocol itself was implemented using the open-source \texttt{ur\_rtde} C++ library developed by SDU Robotics \cite{SDUrtde}. The library abstracts the complexities of the binary RTDE protocol, providing a user-friendly object-oriented wrapper, while logically splitting the interface in 3 parts; control, receive and I/O. This allows the user to control movement and data collection separately and at the same time. For this project, the I/O interface was not used as the gripper is controlled on a dedicated separate TCP/IP connection. 

The \texttt{ur\_rtde} library provides C++ movement methods, such as \texttt{moveJ} and \texttt{moveL}, that closely correspond to those found in the UR5 teach pendant. Since the movement path for the throwing sequence was pre-computed, the main control loop utilizes the non-blocking \texttt{speedJ} control command for execution. This command allows the user to continuously input a target joint speed vector, $\mathbf{\dot{q}}_{\text{target}}$, at the control loop frequency (125 Hz for the UR5). The command also requires a specified acceleration limit to reach the target speeds, and a $\Delta t$ (time step) parameter to define the duration of the current control interval. By looping through the pre-computed joint speed sequence, $\mathbf{\dot{q}}$, at the 125 Hz rate, the desired throwing movement is executed.

Movements other than the throwing sequence are also required, these movements use \texttt{moveJ} as to limit the risk of hitting a joint boundary, while not having to map the movement fully beforehand. \texttt{moveJ} allows the user to input a target joint position, a desired speed and acceleration. The move is then executed by interpolating linearly in joint space, which ensures a controlled path and reduces the range of motion needed at each joint. Theoretically, joint boundaries should never be violated using this movement type, provided both the start and end configurations are within the joint limits. This movement type is used for the static ball pickup sequence, for moving the robot to the throwing sequence start position, and for returning to a defined home configuration after the throw.
