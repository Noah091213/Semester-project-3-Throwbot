\chapter{Trajectory Planning}
\label{chap:trajectoryplanning}

\section{Physics}

The first part of finding the trajectory of an object is to find its path given two coordinates, the release and target coordinate. With the given coordinates yaw, pitch and start velocity ($\mathbf{v}_{\text{0}}$) can be calculated for the release position. Assuming that the release coordinate is in (0. 0. 0) yaw is calculated with $\arctan_2(x, y)$. To calculate $\mathbf{v}_{\text{0}}$ the following function, where $\theta_z$ is pitch, is used: 
\begin{align}
	v_0 = \sqrt{\frac{g \cdot \sqrt{x² + y²}}{2 \cos^2(\theta_z) (\sqrt{x² + y²} \tan(\theta_z) - z)}}
\end{align}

To find the pitch which has the lowest $\mathbf{v}_{\text{0}}$, 1000 pitches spaced linearly between 22.5 and 90 degrees are checked. 
 
\section{Kinematics}
Given the object trajectory required to hit the target, the movement of the robot can be determined such that the object reaches the desired velocity and direction at the point of release. By moving the tool center point (TCP) and there-by the object, the goal is to have the TCP at the exact location of the release point at the same time as the velocity of the TCP matches the desired velocity and direction of the ball trajectory. 

To create the movement sequence the desired joint pose and velocity will be determined for a set of time steps spaced 8ms apart to match the robots frequency ($f$) of 125Hz. The first step in this process is to ensure that the positions and angles given in world frame can be converted to the robots base frame.

\subsection{Calibration}
To enable accurate positioning of the robot relative to points defined on the table, a calibration between the robot base frame and the world frame is required. Since the robot operates in its own coordinate system, a rigid-body transformation must relate world-frame coordinates to robot-frame coordinates, as outlined in standard robot–table calibration methods \cite{Calibration}. This transformation consists of a rotation aligning the coordinate axes and a translation accounting for the offset between the frame origins.

The transformation was estimated using 52 reference points on the table, for which corresponding positions were recorded in both the world frame and the robot frame. A dedicated calibration tool was mounted on the robot tool flange to improve TCP alignment, and the resulting datasets were imported into MATLAB. Prior to estimation, both point sets were centered by subtracting their respective centroids to improve numerical robustness.

The rigid-body transformation was computed using an singular value decomposition (SVD) based least-squares method. The rotation matrix was obtained from the SVD of a correlation matrix constructed from the centered datasets, while the translation vector was computed from the difference between the centroids. The calibration quality was evaluated using the root mean square (RMS) error. The initial calibration resulted in RMS errors between 0.1991 m and 1.3078 m, revealing the presence of inconsistent measurements. After removing four identified outliers, the calibration was repeated, reducing the RMS error to the range 0.0005 m to 0.0012 m. The results of the initial and repeated calibration procedures are shown in Figures~\ref{fig:FirstCalibration} and~\ref{fig:FinalCalibration}, respectively.

\begin{figure}[htbp]
	\centering
	\begin{minipage}{0.48\textwidth}
		\centering
		\includegraphics[width=\linewidth]{images/FirstCalibration.png}
		\caption{Visualization of the initial robot-table calibration using the complete dataset.}
		\label{fig:FirstCalibration}
	\end{minipage}
	\hfill
	\begin{minipage}{0.48\textwidth}
		\centering
		\includegraphics[width=\linewidth]{images/FinalCalibration.png}
		\caption{Visualization of the repeated robot-table calibration after removal of identified outliers.}
		\label{fig:FinalCalibration}
	\end{minipage}
\end{figure}


\subsection{Robot Path Planning}
With the homogeneous transformation matrix from world frame to base frame found, the robots required path can be determined. This process is done using MATLAB with the Robotics System Toolbox (RST) \cite{RoboticsToolbox}. The path is split into two sections, what happens before the release point and what happens after. These two path sequences will be called lead-up and follow-through. 

\subsubsection{Inverse Kinematics}
To determine the joint positions for the release point, a generalized inverse kinematics solver from RST is used. This optimization-based solver balances four weighted inputs to find a solution ($\mathbf{q}_{\text{release}}$) within physical limits:

\textbf{Joint Limits (Weight: 500)}: Sourced from the UR5 teach pendant, these include a safety offset to prevent the robot from reaching boundaries, which would restrict lead-up and follow-through movement.

\textbf{Release Position (Weight: 50)}: The target Cartesian coordinates are transformed from the world frame to the robot’s base frame using the calibration matrix.

\textbf{TCP Orientation (Weight: 1)}: Derived from the ball’s yaw and pitch, the orientation ensures the gripper does not obstruct the ball post-release. A rotation matrix is constructed in the world frame where the Y-axis opposes the trajectory vector, the Z-axis points downward (remaining orthogonal), and the X-axis completes the right-handed frame. This is then transformed to the base frame.

\textbf{Desired Joint Pose}: Set to the center of each joint's movement range to maximize available range of motion in both directions.

The weights are arbitrarily set based on the inputs' relative importance for path planning, with joint limits being the single most important factor. TCP position outweighs orientation, as it is more important to be at the correct position. If a solution is found, it is validated against a 5 mm tolerance; the Euclidean distance between the desired and computed TCP positions. If the solver fails, an error code is generated.

\subsubsection{Joint velocity at release}With the joint pose for the release position found, the required joint velocities at release can be determined based on the ball's desired velocity magnitude ($vel$) and direction vector ($\mathbf{dir}$). The desired TCP linear velocity is defined as $\mathbf{v}_{\text{release}} = vel \cdot \mathbf{dir}$. First, the Jacobian ($\mathbf{J}$) is found for the joint pose. This $6 \times 6$ matrix is derived from the robot's kinematic model using the provided MATLAB function \cite{matlabfunction}. The first three rows determine the TCP linear velocity, and the last three rows determine the TCP angular velocity. For this task, only the linear velocity portion is necessary, making $\mathbf{J}_{\text{vel}}$ a $3 \times 6$ matrix. Since the UR5 is kinematically redundant for this task (6 joints, 3 required outputs), and because certain joints (like Wrist 2) are highly restricted, a weighted pseudo-inverse of the Jacobian is used. This requires defining a diagonal joint cost matrix, $\mathbf{W}$, where higher values impose a greater penalty on the corresponding joint velocity. With the cost matrix, the weighted pseudo-inverse ($\mathbf{J}_{\text{weighted}}^{+}$) is calculated using the following formula:
\begin{equation}
	\mathbf{J}_{\text{weighted}}^{+} = \mathbf{W}^{-1} \mathbf{J}_{\text{vel}}^T (\mathbf{J}_{\text{vel}} \mathbf{W}^{-1} \mathbf{J}_{\text{vel}}^T)^{-1}
\end{equation}

With the weighted pseudo-inverse, the required joint velocities at release ($\mathbf{\dot{q}}_{\text{release}}$) can be determined:

\begin{equation}
	\mathbf{\dot{q}}_{\text{release}} = \mathbf{J}_{\text{weighted}}^{+} \mathbf{v}_{\text{release}}
\end{equation}

\subsubsection{Lead-up}The lead-up path is determined in joint space based on the computed release position ($\mathbf{q}_{\text{release}}$) and the required release velocity ($\mathbf{\dot{q}}_{\text{release}}$). In order to limit the joints' movements, the path is generated linearly for each joint using a constant acceleration ($a$). The path is computed backwards from the release point until each joint reaches a velocity of 0. For each joint $j$ the number of time steps required to hit the desired velocity is determined:

\begin{align}
	\text{time}_{\mathbf{j}} &= \frac{|\mathbf{\dot{q}}_{\text{release},j}|}{a} \\
	\text{steps}_{\mathbf{j}} &= \lceil \text{time}_{\mathbf{j}} \cdot f \rceil
\end{align}

The joint requiring the most steps determines the total steps for the trajectory ($\text{steps}_{\text{max}} = \max(\text{steps}_j)$). Then the position ($\mathbf{q}$) and velocity ($\mathbf{\dot{q}}$) at each time step $i$ can be determined for each joint $j$ using the time step $\Delta t = 1 / f$. The iteration index $i$ runs backward from $i=1$ (the release point) to $i=\text{steps}_{\text{max}}$ (the start of the movement):

\begin{align}
	\mathbf{\dot{q}}_{i,j} &= \mathbf{\dot{q}}_{\text{release},j} \cdot \max\left(\left(1 - \frac{i}{\text{steps}_{\mathbf{j}}}\right), 0\right) \\
	\mathbf{q}_{i,j} &= \mathbf{q}_{i-1,j} - \mathbf{\dot{q}}_{i,j} \cdot \Delta t
\end{align}

The $\max(\cdot, 0)$ function ensures that joints which complete their movement faster than the global $\text{steps}_{\text{max}}$ will have their velocity clipped to zero for the remainder of the trajectory, thereby synchronizing the start and end of all joint movements. With the full lead-up sequence determined it can now be checked against the joint limits. Each joint's positions is checked against their respective limits, if any joint exceeds the boundaries, an error code is registered (see section \ref{statuscode}).

\subsubsection{Follow-through}
The follow-through is determined in Cartesian space rather than joint space to allow the TCP to decelerate in a linear motion in the direction of the ball's initial trajectory. This is done to allow for small errors in the timing of the release. Should the ball be released slightly too late, it will still be traveling in the correct direction at a reduced speed, negating some of the impact of the delayed release. The method for determining the follow-through path is similar to the method used for the lead-up, but since it is done in Cartesian space, some changes are required.

Rather than using a constant deceleration in joint space to compute the require time, the opposite is done here. A static time of 0.5 seconds is set for the follow-through, which generates a static number of time steps ($\text{steps}_{\text{follow}}$). The desired velocity in Cartesian space can then be calculated for each time step such that the TCP decelerates at a constant rate until the velocity is 0 at the last time step in the sequence. At each time step, the desired Cartesian velocity can be converted to joint velocities using that positions Jacobian. The Jacobian is again found using the kinematics function and transformed into a weighted pseudo-inverse ($\mathbf{J}_\text{weighted,i}^{+}$) with only the velocity parameters. With the joint velocity, the joint position can be updated. The iteration index $i$ runs from $i = 1$ to $\text{steps}_{\text{follow}}$

\begin{align}
	\text{steps}_{\text{follow}} &= round(0.5 \cdot f) \\
	\mathbf{v}_\text{i} &= (1 - \frac{i}{\text{steps}_{\text{follow}}}) \cdot \mathbf{v}_\text{release} \\
	\mathbf{\dot{q}}_\text{i} &= \mathbf{J}_\text{weighted,i}^{+} * \mathbf{v}_\text{i} \\
	\mathbf{q}_\text{i} &= \mathbf{q}_\text{i-1} + \mathbf{\dot{q}}_\text{i} \cdot \Delta t
\end{align} 

Since the follow-through trajectory is generated in Cartesian space, it is not limiting the amount of space needed in joint space. Therefore, the joints' positions at each time step is checked against their respective limits, and their velocity set to 0 if the joint gets within 5 degrees of the limit. This does mean that some follow-through trajectories will not be linear in Cartesian space for the full movement, but will stay linear for as long as the joints allow.

\subsubsection{Safety check}
With the lead-up, release point, and follow-through generated the entire sequence can be combined to create the full movement. Since only the joint limits have been checked during the generation of the movement, the TCP limits in Cartesian space must be checked by the end to ensure that movement will not push the TCP outside its boundaries. This is done by finding the TCP position at each time step using forward kinematics and checking its x, y and z coordinate against the limits. If any position is outside the limits, an error code is registered (see section \ref{statuscode}).

\subsubsection{Status codes} \label{statuscode}
Path generation utilizes two code types to track safety and accuracy. Error codes (2x) indicate a safety limit breach (e.g., TCP or joint limits) that terminates generation. Status codes (1xxxxx) allow generation to continue but flag imperfections; while 100000 represents a nominal path, each subsequent digit tracks a specific deviation, such as the IK release offset (mm) or velocity loss (\%).

\begin{itemize}[noitemsep]
	\item 100000: All good
	\item 1x0000: IK release point is off by x in mm
	\item 10x000: Release velocity loss by x in \%
	\item 100100: Joint angles clipped to limits in follow-through
	\item 20: No IK solution for release configuration
	\item 21: IK release point is off by > 5mm
	\item 22: Release velocity loss of > 3\%
	\item 23: Joint limits exceeded in lead-up
	\item 24: TCP limits exceeded
	\item 26: Release point too close to target point
\end{itemize}

\subsubsection{Release Points}
As the generation of both the ball's trajectory and the robot's movement is determined based on the release point, some release points may lead to a solution while others may not. In order to achieve the highest likelihood that a solution is found, the calculations are run multiple times using a sequence of 7 release points. If the first release points does not generate a valid solution, the next is tried and so on. The 7 points were chosen during the test phase of the system and should be enough to cover most of the target area that is physically possible to hit. If no solution is found for any of the 7 points, it is likely that no release point exists that would generate a solution for that specific target point. MATLAB will return a full status code with all 7 error codes to the C++ program, letting the user know that the target is not within reach, while giving some indication as to what makes the target impossible to hit.

\subsection{MATLAB Communication}
To run the MATLAB script, the MATLAB Engine API is used. This allows the C++ program to start the MATLAB script, pass data over, and return any data from the calculations. 
MATLAB Engine works by starting the script as a separate process, passing the data through the API thus copying the data in a format MATLAB can understand, running the script through, returning it through the API and lastly converting the data to something C++ can understand and closing the MATLAB process. 
Because MATLAB Engine relies on its own MATLAB International Components for Unicode (ICU), the program must be started through a shell script, running on top of the default Linux ICU. The reason the MATLAB ICU cannot be loaded solely is because Pylon, the library for vision, requires access to the standard Linux ICU.










